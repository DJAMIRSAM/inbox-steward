{% extends "base.html" %}
{% block content %}
{% include "partials/debug_content.html" %}

<div
  id="debug-progress-overlay"
  class="debug-progress-overlay"
  aria-hidden="true"
  role="status"
>
  <div class="debug-progress-panel">
    <div class="flex items-start justify-between gap-4">
      <div>
        <p class="text-xs font-semibold uppercase tracking-wide text-brand-500">Diagnostics running</p>
        <h2 class="mt-1 text-lg font-semibold text-slate-800 dark:text-slate-100" data-progress-title>Working…</h2>
      </div>
      <button
        type="button"
        class="debug-progress-close"
        data-progress-close
        aria-label="Hide progress"
      >
        ✕
      </button>
    </div>
    <p class="mt-3 text-sm text-slate-600 dark:text-slate-300" data-progress-status>Preparing diagnostics…</p>
    <div class="mt-4 h-2 w-full rounded-full bg-slate-200 dark:bg-slate-800 overflow-hidden">
      <div class="h-full bg-brand-600 transition-all duration-200" data-progress-bar style="width: 0%"></div>
    </div>
    <ul class="mt-4 space-y-3" data-progress-list></ul>
  </div>
</div>

<script type="application/json" id="debug-progress-data">{{ progress_steps | tojson }}</script>
<script>
  (function () {
    const progressConfigEl = document.getElementById('debug-progress-data');
    const progressConfig = progressConfigEl ? JSON.parse(progressConfigEl.textContent || '{}') : {};
    const overlay = document.getElementById('debug-progress-overlay');
    if (!overlay) {
      return;
    }
    const progressList = overlay.querySelector('[data-progress-list]');
    const progressTitle = overlay.querySelector('[data-progress-title]');
    const progressStatus = overlay.querySelector('[data-progress-status]');
    const progressBar = overlay.querySelector('[data-progress-bar]');
    const closeButton = overlay.querySelector('[data-progress-close]');

    let activeJob = null;
    let polling = null;
    let hideTimeout = null;

    const resetOverlay = () => {
      overlay.classList.remove('is-visible', 'has-error');
      overlay.setAttribute('aria-hidden', 'true');
      progressStatus.textContent = 'Preparing diagnostics…';
      progressBar.style.width = '0%';
      progressBar.classList.remove('bg-emerald-500', 'bg-rose-500');
      if (progressList) {
        progressList.innerHTML = '';
      }
      if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
      }
    };

    const ensureSteps = (action) => {
      const config = progressConfig[action];
      if (!config || !Array.isArray(config.steps) || !config.steps.length) {
        return null;
      }
      return config;
    };

    const createStepRow = (step) => {
      const li = document.createElement('li');
      li.className = 'debug-step';
      li.dataset.stepKey = step.key;
      li.dataset.status = step.status || 'pending';
      const icon = document.createElement('span');
      icon.className = 'debug-step-icon';
      icon.textContent = '⏳';
      const body = document.createElement('div');
      body.className = 'debug-step-body';
      const title = document.createElement('div');
      title.className = 'debug-step-title';
      title.textContent = step.label;
      const detail = document.createElement('div');
      detail.className = 'debug-step-detail';
      detail.textContent = step.detail || '';
      body.appendChild(title);
      body.appendChild(detail);
      li.appendChild(icon);
      li.appendChild(body);
      return li;
    };

    const updateStepRow = (li, step) => {
      if (!li) return;
      li.dataset.status = step.status || 'pending';
      const icon = li.querySelector('.debug-step-icon');
      const detail = li.querySelector('.debug-step-detail');
      if (detail) {
        detail.textContent = step.detail || '';
      }
      if (icon) {
        const status = step.status;
        if (status === 'complete') {
          icon.textContent = '✓';
        } else if (status === 'running') {
          icon.textContent = '⏳';
        } else if (status === 'error') {
          icon.textContent = '⚠️';
        } else {
          icon.textContent = '…';
        }
      }
    };

    const renderSteps = (action) => {
      const config = ensureSteps(action);
      if (!progressList || !config) {
        return;
      }
      progressList.innerHTML = '';
      config.steps.forEach((step) => {
        const li = createStepRow(step);
        progressList.appendChild(li);
      });
    };

    const applyStepUpdates = (steps) => {
      if (!progressList || !Array.isArray(steps)) return;
      let completed = 0;
      let runningLabel = null;
      steps.forEach((step) => {
        const li = progressList.querySelector(`li[data-step-key="${step.key}"]`);
        updateStepRow(li, step);
        if (step.status === 'complete') {
          completed += 1;
        }
        if (step.status === 'running') {
          runningLabel = step.label;
        }
        if (step.status === 'error' && step.detail && progressStatus) {
          progressStatus.textContent = step.detail;
        }
      });
      if (progressBar) {
        const total = progressList.children.length || 1;
        const percent = Math.round((completed / total) * 100);
        progressBar.style.width = `${percent}%`;
      }
      if (runningLabel && progressStatus) {
        progressStatus.textContent = runningLabel;
      }
    };

    const markComplete = (success = true, message = null) => {
      if (progressBar) {
        progressBar.style.width = '100%';
        progressBar.classList.toggle('bg-emerald-500', success);
        progressBar.classList.toggle('bg-rose-500', !success);
      }
      if (progressStatus) {
        progressStatus.textContent = message || (success ? 'Diagnostics finished.' : 'Diagnostics failed.');
      }
      overlay.classList.toggle('has-error', !success);
      hideTimeout = setTimeout(() => {
        overlay.classList.remove('is-visible');
        overlay.setAttribute('aria-hidden', 'true');
      }, 1600);
    };

    const showOverlay = (action) => {
      const config = progressConfig[action];
      if (progressTitle) {
        progressTitle.textContent = config && config.title ? config.title : 'Running diagnostics';
      }
      renderSteps(action);
      overlay.classList.add('is-visible');
      overlay.setAttribute('aria-hidden', 'false');
    };

    const stopPolling = () => {
      if (polling) {
        clearTimeout(polling);
        polling = null;
      }
    };

    const pollJob = async (jobId, action) => {
      try {
        const response = await fetch(`/debug/status/${jobId}`);
        if (!response.ok) {
          throw new Error('Status check failed');
        }
        const payload = await response.json();
        applyStepUpdates(payload.steps || []);
        if (payload.status === 'completed') {
          markComplete(true, 'Diagnostics complete.');
          if (payload.html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(payload.html, 'text/html');
            const next = doc.querySelector('#debug-root');
            const current = document.querySelector('#debug-root');
            if (next && current) {
              current.replaceWith(next);
              bindForms();
            }
          }
          stopPolling();
          activeJob = null;
          return;
        }
        if (payload.status === 'failed') {
          const detail = payload.error || 'Diagnostics failed to complete.';
          markComplete(false, detail);
          stopPolling();
          activeJob = null;
          return;
        }
        polling = setTimeout(() => pollJob(jobId, action), 500);
      } catch (error) {
        console.error(error);
        markComplete(false, 'Unable to update progress.');
        stopPolling();
        activeJob = null;
      }
    };

    const startJob = async (action) => {
      if (activeJob) {
        return;
      }
      const formData = { action };
      try {
        const response = await fetch('/debug/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData),
        });
        if (!response.ok) {
          throw new Error('Unable to start diagnostics');
        }
        const payload = await response.json();
        if (!payload.job_id) {
          throw new Error('Missing job identifier');
        }
        activeJob = payload.job_id;
        pollJob(activeJob, action);
      } catch (error) {
        console.error(error);
        markComplete(false, 'Diagnostics could not be started.');
      }
    };

    const bindForms = () => {
      const forms = document.querySelectorAll('[data-debug-form]');
      forms.forEach((form) => {
        if (form.dataset.debugBound === '1') {
          return;
        }
        form.dataset.debugBound = '1';
        form.addEventListener(
          'submit',
          (event) => {
            const actionInput = form.querySelector('[name="action"]');
            if (!actionInput) {
              return;
            }
            const action = actionInput.value;
            if (!action || !progressConfig[action]) {
              return;
            }
            event.preventDefault();
            resetOverlay();
            showOverlay(action);
            startJob(action);
          },
          { once: false }
        );
      });
    };

    if (closeButton) {
      closeButton.addEventListener('click', () => {
        if (activeJob) {
          return;
        }
        overlay.classList.remove('is-visible');
        overlay.setAttribute('aria-hidden', 'true');
      });
    }

    resetOverlay();
    bindForms();
  })();
</script>
{% endblock %}
